<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_171) on Wed May 08 16:46:28 CST 2019 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>com.lmax.disruptor</title>
<meta name="date" content="2019-05-08">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="com.lmax.disruptor";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../overview-summary.html">概览</a></li>
<li class="navBarCell1Rev">程序包</li>
<li>类</li>
<li><a href="package-use.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>上一个程序包</li>
<li><a href="../../../com/lmax/disruptor/dsl/package-summary.html">下一个程序包</a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?com/lmax/disruptor/package-summary.html" target="_top">框架</a></li>
<li><a href="package-summary.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="程序包" class="title">程序包&nbsp;com.lmax.disruptor</h1>
<div class="docSummary">
<div class="block">
        The Disruptor is a concurrent programming framework for exchanging and coordinating work as a continuous series of events.</div>
</div>
<p>请参阅:&nbsp;<a href="#package.description">说明</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="接口概要表, 列表接口和解释">
<caption><span>接口概要</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">接口</th>
<th class="colLast" scope="col">说明</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/BatchStartAware.html" title="com.lmax.disruptor中的接口">BatchStartAware</a></td>
<td class="colLast">
<div class="block">批量启动的作用: 每次循环取得一批可用事件后，在实际处理前调用</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/Cursored.html" title="com.lmax.disruptor中的接口">Cursored</a></td>
<td class="colLast">
<div class="block">Cursored接口只有一个方法，getCursor就是用来获取当前游标的位置，也就是用来获取当前生产者的实时位置。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/DataProvider.html" title="com.lmax.disruptor中的接口">DataProvider</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">DataProvider 提供了根据序列获取对应的对象有两个地方调用。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventFactory.html" title="com.lmax.disruptor中的接口">EventFactory</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">由<a href="../../../com/lmax/disruptor/RingBuffer.html" title="com.lmax.disruptor中的类"><code>RingBuffer</code></a>调用，以预先调用所有事件以填充RingBuffer。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventHandler.html" title="com.lmax.disruptor中的接口">EventHandler</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">回调接口，用于处理<a href="../../../com/lmax/disruptor/RingBuffer.html" title="com.lmax.disruptor中的类"><code>RingBuffer</code></a>中可用的事件</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventPoller.Handler.html" title="com.lmax.disruptor中的接口">EventPoller.Handler</a>&lt;T&gt;</td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventProcessor.html" title="com.lmax.disruptor中的接口">EventProcessor</a></td>
<td class="colLast">
<div class="block">介绍: EventProcessor需要是一个Runnable的实现,它将使用适当的等待策略从环形队列轮询事件;
 不太可能需要自己实现此接口,在第一个实例中使用<a href="../../../com/lmax/disruptor/EventHandler.html" title="com.lmax.disruptor中的接口"><code>EventHandler</code></a>接口以及预先提供的BatchEventProcessor。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventReleaseAware.html" title="com.lmax.disruptor中的接口">EventReleaseAware</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventReleaser.html" title="com.lmax.disruptor中的接口">EventReleaser</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventSequencer.html" title="com.lmax.disruptor中的接口">EventSequencer</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">EventSequencer扩展了Sequenced，提供了一些序列功能；同时扩展了DataProvider，提供了按序列值来获取数据的功能。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventSink.html" title="com.lmax.disruptor中的接口">EventSink</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">这个类主要是提供发布事件(就是往队列上放数据)的功能,接口上定义了以各种姿势发布事件的方法
 
 1: EventSink接口是用来发布Event的,在发布的同时,调用绑定的Translator来初始化并填充Event
 2: 填充Event是通过实现EventTranslator,EventTranslatorOneArg，EventTranslatorTwoArg，EventTranslatorThreeArg,EventTranslatorVararg这些EventTranslator来做的
 3: 发布流程:申请下一个序列-申请成功则获取对应槽的Event-利用translator初始化并填充对应槽的Event-发布Event; translator用户实现,用于初始化Event</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventTranslator.html" title="com.lmax.disruptor中的接口">EventTranslator</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">在发布事件时需要传一个事件转换的接口，内部用这个接口做一下数据到事件的转换。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventTranslatorOneArg.html" title="com.lmax.disruptor中的接口">EventTranslatorOneArg</a>&lt;T,A&gt;</td>
<td class="colLast">
<div class="block">实现将另一个数据表示转换为<a href="../../../com/lmax/disruptor/RingBuffer.html" title="com.lmax.disruptor中的类"><code>RingBuffer</code></a>声明的事件</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventTranslatorThreeArg.html" title="com.lmax.disruptor中的接口">EventTranslatorThreeArg</a>&lt;T,A,B,C&gt;</td>
<td class="colLast">
<div class="block">实现将另一个数据表示转换为<a href="../../../com/lmax/disruptor/RingBuffer.html" title="com.lmax.disruptor中的类"><code>RingBuffer</code></a>声明的事件</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventTranslatorTwoArg.html" title="com.lmax.disruptor中的接口">EventTranslatorTwoArg</a>&lt;T,A,B&gt;</td>
<td class="colLast">
<div class="block">实现将另一个数据表示转换为<a href="../../../com/lmax/disruptor/RingBuffer.html" title="com.lmax.disruptor中的类"><code>RingBuffer</code></a>声明的事件</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventTranslatorVararg.html" title="com.lmax.disruptor中的接口">EventTranslatorVararg</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">实现将另一个数据表示转换为<a href="../../../com/lmax/disruptor/RingBuffer.html" title="com.lmax.disruptor中的类"><code>RingBuffer</code></a>声明的事件</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/ExceptionHandler.html" title="com.lmax.disruptor中的接口">ExceptionHandler</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block"><a href="../../../com/lmax/disruptor/BatchEventProcessor.html" title="com.lmax.disruptor中的类"><code>BatchEventProcessor</code></a>事件处理周期中未捕获异常的回调处理程序</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/LifecycleAware.html" title="com.lmax.disruptor中的接口">LifecycleAware</a></td>
<td class="colLast">
<div class="block">在<a href="../../../com/lmax/disruptor/EventHandler.html" title="com.lmax.disruptor中的接口"><code>EventHandler</code></a>中实现此接口，以便在<a href="../../../com/lmax/disruptor/BatchEventProcessor.html" title="com.lmax.disruptor中的类"><code>BatchEventProcessor</code></a>的线程启动和关闭时得到通知。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/SequenceBarrier.html" title="com.lmax.disruptor中的接口">SequenceBarrier</a></td>
<td class="colLast">
<div class="block">SequenceBarrier由Sequencer生成并且包含了已经发布的Sequence的引用这些Sequence源于Sequencer和一些独立的消费者的Sequence。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/Sequenced.html" title="com.lmax.disruptor中的接口">Sequenced</a></td>
<td class="colLast">
<div class="block">Sequenced接口提供的方法都是用来给生产者使用, 用于申请序列, 发布序列的</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/Sequencer.html" title="com.lmax.disruptor中的接口">Sequencer</a></td>
<td class="colLast">
<div class="block">Sequencer接口的很多功能是提供给事件发布者用的; 通过Sequencer可以得到一个SequenceBarrier, 给消费者使用
 Sequencer接口提供了2种实现：SingleProducerSequencer和MultiProducerSequencer;
 
 用于声明访问数据结构的序列（sequences），他的行踪依赖于Sequences
 Sequencer这是Disruptor真正的核心;实现了这个接口的两种生产者(单生产者和多生产者)均实现了所有的并发算法,为了在生产者和消费者之间进行准确快速的数据传递</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/SequenceReportingEventHandler.html" title="com.lmax.disruptor中的接口">SequenceReportingEventHandler</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">由<a href="../../../com/lmax/disruptor/BatchEventProcessor.html" title="com.lmax.disruptor中的类"><code>BatchEventProcessor</code></a>用于设置回调，允许<a href="../../../com/lmax/disruptor/EventHandler.html" title="com.lmax.disruptor中的接口"><code>EventHandler</code></a>在完成消费事件时,
 通知EventHandler#onEvent(T，long，boolean)调用之后发生这种情况
 
 通常，这将在处理程序执行某种批处理操作(例如写入IO设备)时使用;
 在操作完成后，实现应该调用<a href="../../../com/lmax/disruptor/Sequence.html#set-long-"><code>Sequence.set(long)</code></a>来更新序列，并允许依赖于此处理程序的其他进程进行</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/TimeoutHandler.html" title="com.lmax.disruptor中的接口">TimeoutHandler</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/WaitStrategy.html" title="com.lmax.disruptor中的接口">WaitStrategy</a></td>
<td class="colLast">
<div class="block">Disruptor框架中提供了如下几种等待策略: 
 BlockingWaitStrategy：默认的等待策略。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/WorkHandler.html" title="com.lmax.disruptor中的接口">WorkHandler</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">回调接口，用于处理<a href="../../../com/lmax/disruptor/RingBuffer.html" title="com.lmax.disruptor中的类"><code>RingBuffer</code></a>中可用的工作单元</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="类概要表, 列表类和解释">
<caption><span>类概要</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">类</th>
<th class="colLast" scope="col">说明</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/AbstractSequencer.html" title="com.lmax.disruptor中的类">AbstractSequencer</a></td>
<td class="colLast">
<div class="block">各种sequencer的基类（单/多） 提供公有的功能，如gating sequences的管理（add/remove） 和 当前光标的所在位置。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/AggregateEventHandler.html" title="com.lmax.disruptor中的类">AggregateEventHandler</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block"><a href="../../../com/lmax/disruptor/EventHandler.html" title="com.lmax.disruptor中的接口"><code>EventHandler</code></a>的聚合集合，按顺序为每个事件调用</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/BatchEventProcessor.html" title="com.lmax.disruptor中的类">BatchEventProcessor</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">event模式单线程处理。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/BlockingWaitStrategy.html" title="com.lmax.disruptor中的类">BlockingWaitStrategy</a></td>
<td class="colLast">
<div class="block">BlockingWaitStrategy的实现方法是阻塞等待。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/BusySpinWaitStrategy.html" title="com.lmax.disruptor中的类">BusySpinWaitStrategy</a></td>
<td class="colLast">
<div class="block">BusySpinWaitStrategy策略，它使用忙碌的自旋循环,让<a href="../../../com/lmax/disruptor/EventProcessor.html" title="com.lmax.disruptor中的接口"><code>EventProcessor</code></a>等待屏障
 
 这种策略会利用CPU资源来避免系统调用带来的延迟抖动，当线程可以绑定到指定CPU(核)的时候，最好使用这个策略。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventPoller.html" title="com.lmax.disruptor中的类">EventPoller</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">可以用于RingBuffer中获取事件并处理，这个获取方式是无等待的，如果当前没有可处理的事件，会返回相应的状态-PollState。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/FatalExceptionHandler.html" title="com.lmax.disruptor中的类">FatalExceptionHandler</a></td>
<td class="colLast">
<div class="block">SEVERE(严重)的异常处理程序的便捷实现。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/FixedSequenceGroup.html" title="com.lmax.disruptor中的类">FixedSequenceGroup</a></td>
<td class="colLast">
<div class="block">在单个序列后面隐藏一组序列</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/IgnoreExceptionHandler.html" title="com.lmax.disruptor中的类">IgnoreExceptionHandler</a></td>
<td class="colLast">
<div class="block">使用标准JDK日志记录将异常记录为<code>Level</code>; INFO的异常处理程序的便捷实现</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/LiteBlockingWaitStrategy.html" title="com.lmax.disruptor中的类">LiteBlockingWaitStrategy</a></td>
<td class="colLast">
<div class="block"><a href="../../../com/lmax/disruptor/BlockingWaitStrategy.html" title="com.lmax.disruptor中的类"><code>BlockingWaitStrategy</code></a>的变化,当锁无效时,试图消除有条件的唤醒;
 相比BlockingWaitStrategy,LiteBlockingWaitStrategy的实现方法也是阻塞等待,但它会减少一些不必要的唤醒;
 从源码的注释上看，这个策略在基准性能测试上是会表现出一些性能提升;
 这种等待策略应该被认为是实验性的，因为官方作者还没有完全证明锁定省略代码的正确性。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/LiteTimeoutBlockingWaitStrategy.html" title="com.lmax.disruptor中的类">LiteTimeoutBlockingWaitStrategy</a></td>
<td class="colLast">
<div class="block"><a href="../../../com/lmax/disruptor/TimeoutBlockingWaitStrategy.html" title="com.lmax.disruptor中的类"><code>TimeoutBlockingWaitStrategy</code></a>的一个变形，当锁无效时，试图无条件唤醒。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/MultiProducerSequencer.html" title="com.lmax.disruptor中的类">MultiProducerSequencer</a></td>
<td class="colLast">
<div class="block">适用于跨多个生产者线程排序; MultiProducerSequencer每次获取序列都是从<a href="../../../com/lmax/disruptor/Sequence.html" title="com.lmax.disruptor中的类"><code>Sequence</code></a>中获取的,Sequence中针对value的操作都是原子的
 
 关于<a href="../../../com/lmax/disruptor/Cursored.html#getCursor--"><code>Cursored.getCursor()</code></a>的注意事项: 使用此序列器, 在调用<a href="../../../com/lmax/disruptor/Sequenced.html#next--"><code>Sequenced.next()</code></a>之后更新游标值,
 以确定可读取的最高可用序列, 然后应该使用<a href="../../../com/lmax/disruptor/Sequencer.html#getHighestPublishedSequence-long-long-"><code>Sequencer.getHighestPublishedSequence(long, long)</code></a>
 
        MultiProducerSequencer内部多了一个availableBuffer，是一个int型的数组，size大小和RingBuffer的Size一样大，
        用来追踪Ringbuffer每个槽的状态，构造MultiProducerSequencer的时候会进行初始化，availableBuffer数组中的每个元素会被初始化成-1。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/NoOpEventProcessor.html" title="com.lmax.disruptor中的类">NoOpEventProcessor</a></td>
<td class="colLast">
<div class="block">没有<a href="../../../com/lmax/disruptor/EventProcessor.html" title="com.lmax.disruptor中的接口"><code>EventProcessor</code></a>的操作版本,只跟踪<a href="../../../com/lmax/disruptor/Sequence.html" title="com.lmax.disruptor中的类"><code>Sequence</code></a>。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/PhasedBackoffWaitStrategy.html" title="com.lmax.disruptor中的类">PhasedBackoffWaitStrategy</a></td>
<td class="colLast">
<div class="block"><a href="../../../com/lmax/disruptor/EventProcessor.html" title="com.lmax.disruptor中的接口"><code>EventProcessor</code></a>的分阶段等待策略
 
 当吞吐量和低延迟不如CPU资源那么重要时，可以使用此策略; PhasedBackoffWaitStrategy的实现方法是先自旋(10000次),不行再临时让出调度(yield),
        不行再使用其他的策略进行等待; 可以根据具体场景自行设置自旋时间、yield时间和备用等待策略</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/RingBuffer.html" title="com.lmax.disruptor中的类">RingBuffer</a>&lt;E&gt;</td>
<td class="colLast">
<div class="block">内部用数组来实现, 同时有保存数组长度的域bufferSize和下标掩码indexMask, 还有一个sequencer
 Disruptor最主要的组件，负责存储和更新事件对象。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/Sequence.html" title="com.lmax.disruptor中的类">Sequence</a></td>
<td class="colLast">
<div class="block">1.通过Sequence的一系列的继承关系可以看到, 它真正的用来计数的域是value, 在value的前后各有7个long型的填充值, 这些值在这里的作用是做cpu
 cache line填充,防止发生伪共享 
 2.Sequence类的其他set、get等方法都是通过UNSAFE对象实现对value值的原子操作</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/SequenceGroup.html" title="com.lmax.disruptor中的类">SequenceGroup</a></td>
<td class="colLast">
<div class="block">一个<a href="../../../com/lmax/disruptor/Sequence.html" title="com.lmax.disruptor中的类"><code>Sequence</code></a>组，可以在线程安全的情况下动态添加和删除<a href="../../../com/lmax/disruptor/Sequence.html" title="com.lmax.disruptor中的类"><code>Sequence</code></a>
 
 <a href="../../../com/lmax/disruptor/SequenceGroup.html#get--"><code>SequenceGroup.get()</code></a>和<a href="../../../com/lmax/disruptor/SequenceGroup.html#set-long-"><code>SequenceGroup.set(long)</code></a>方法是无锁的。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/SingleProducerSequencer.html" title="com.lmax.disruptor中的类">SingleProducerSequencer</a></td>
<td class="colLast">
<div class="block">SingleProducerSequencer内部维护cachedValue(事件消费者序列),nextValue(事件生产者序列)。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/SleepingWaitStrategy.html" title="com.lmax.disruptor中的类">SleepingWaitStrategy</a></td>
<td class="colLast">
<div class="block">SleepingWaitStrategy的实现方法是先自旋,不行再临时让出调度(Thread.yield()),不行再短暂的阻塞等待
 对于既想取得高性能,由不想太浪费CPU资源的场景,这个策略是一种比较好的折中方案</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/TimeoutBlockingWaitStrategy.html" title="com.lmax.disruptor中的类">TimeoutBlockingWaitStrategy</a></td>
<td class="colLast">
<div class="block">TimeoutBlockingWaitStrategy的实现方法是阻塞给定的时间，超过时间的话会抛出超时异常。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/WorkerPool.html" title="com.lmax.disruptor中的类">WorkerPool</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">WorkerPool是Work模式下的消费者池，它起到了维护消费者生命周期、关联消费者与事件队列(RingBuffer)、提供工作序列(WorkProcessor多个处理器需要使用统一的workSequence)的作用
 1 多个WorkProcessor组成一个WorkerPool
 2 维护workSequence事件消费者处理的序列
 
 WorkerPool包含一个<a href="../../../com/lmax/disruptor/WorkProcessor.html" title="com.lmax.disruptor中的类"><code>WorkProcessor</code></a>池，它将使用序列，因此可以在一个工作池中进行工作;
 每个<a href="../../../com/lmax/disruptor/WorkProcessor.html" title="com.lmax.disruptor中的类"><code>WorkProcessor</code></a>都管理并调用<a href="../../../com/lmax/disruptor/WorkHandler.html" title="com.lmax.disruptor中的接口"><code>WorkHandler</code></a>来处理事件</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/WorkProcessor.html" title="com.lmax.disruptor中的类">WorkProcessor</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">1.首先，由于是Work模式,必然是多个事件消费者(WorkProcessor)处理同一批事件,那么肯定会存在多个消费者对同一个要处理事件的竞争,所以出现了一个workSequence,所有的消费者都使用这一个workSequence,大家通过对workSequence的原子操作来保证不会处理相同的事件
 2.其次，多个事件消费者和事件发布者之间也需要协调，需要等待事件发布者发布完事件之后才能对其进行处理，这里还是使用序列栅栏来协调(sequenceBarrier.waitFor)。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/YieldingWaitStrategy.html" title="com.lmax.disruptor中的类">YieldingWaitStrategy</a></td>
<td class="colLast">
<div class="block">Yielding 策略：在自旋100次尝试后，让出cpu资源，等待下次cpu调度后再行尝试。</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="枚举概要表, 列表枚举和解释">
<caption><span>枚举概要</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">枚举</th>
<th class="colLast" scope="col">说明</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/EventPoller.PollState.html" title="com.lmax.disruptor中的枚举">EventPoller.PollState</a></td>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="异常错误概要表, 列表异常错误和解释">
<caption><span>异常错误概要</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">异常错误</th>
<th class="colLast" scope="col">说明</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/AlertException.html" title="com.lmax.disruptor中的类">AlertException</a></td>
<td class="colLast">
<div class="block">Used to alert <a href="../../../com/lmax/disruptor/EventProcessor.html" title="com.lmax.disruptor中的接口"><code>EventProcessor</code></a>s waiting at a <a href="../../../com/lmax/disruptor/SequenceBarrier.html" title="com.lmax.disruptor中的接口"><code>SequenceBarrier</code></a> of status changes.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/InsufficientCapacityException.html" title="com.lmax.disruptor中的类">InsufficientCapacityException</a></td>
<td class="colLast">
<div class="block">如果在没有消耗序列的情况下，无法将值插入RingBuffer，则抛出异常;
 在使用<a href="../../../com/lmax/disruptor/RingBuffer.html#tryNext--"><code>RingBuffer.tryNext()</code></a>调用声明时特别使用。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../com/lmax/disruptor/TimeoutException.html" title="com.lmax.disruptor中的类">TimeoutException</a></td>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="程序包com.lmax.disruptor的说明">程序包com.lmax.disruptor的说明</h2>
<div class="block"><p>
        The Disruptor is a concurrent programming framework for exchanging and coordinating work as a continuous series of events.
        It can be used as an alternative to wiring processing stages together via queues.  The Disruptor design has the
        characteristics of generating significantly less garbage than queues and separates the concurrency concerns so
        non-locking algorithms can be employed resulting in greater scalability and performance.
    </p>
    <p>
        It works on the principle of having a number of stages that are each single threaded with local state and memory.
        No global memory exists and all communication is achieved by passing messages/state via managed ring buffers.
    </p>
    <p>
        Almost any graph or pipeline structure can be composed via one or more Disruptor patterns.
    </p>

    <p>
        <b>UniCast a series of items between 1 publisher and 1 EventProcessor.</b>
        <pre>
                                          track to prevent wrap
                                          +------------------+
                                          |                  |
                                          |                  v
+----+    +-----+            +----+    +====+    +====+   +-----+
| P1 |--->| EP1 |            | P1 |--->| RB |<---| SB |   | EP1 |
+----+    +-----+            +----+    +====+    +====+   +-----+
                                  claim      get    ^        |
                                                    |        |
                                                    +--------+
                                                      waitFor
        </pre>
    </p>
    <p>
        <b>Sequence a series of messages from multiple publishers</b>
        <pre>
                                         track to prevent wrap
                                         +--------------------+
                                         |                    |
                                         |                    v
+----+                       +----+    +====+    +====+    +-----+
| P1 |-------+               | P1 |--->| RB |<---| SB |    | EP1 |
+----+       |               +----+    +====+    +====+    +-----+
             v                           ^   get    ^         |
+----+    +-----+            +----+      |          |         |
| P2 |--->| EP1 |            | P2 |------+          +---------+
+----+    +-----+            +----+      |            waitFor
             ^                           |
+----+       |               +----+      |
| P3 |-------+               | P3 |------+
+----+                       +----+
        </pre>
    </p>
    <p>
        <b>Pipeline a series of messages</b>
        <pre>
                          +----+    +-----+    +-----+    +-----+
                          | P1 |--->| EP1 |--->| EP2 |--->| EP3 |
                          +----+    +-----+    +-----+    +-----+



                          track to prevent wrap
             +----------------------------------------------------------------+
             |                                                                |
             |                                                                v
+----+    +====+    +=====+    +-----+    +=====+    +-----+    +=====+    +-----+
| P1 |--->| RB |    | SB1 |<---| EP1 |<---| SB2 |<---| EP2 |<---| SB3 |<---| EP3 |
+----+    +====+    +=====+    +-----+    +=====+    +-----+    +=====+    +-----+
     claim   ^  get    |   waitFor           |   waitFor           |  waitFor
             |         |                     |                     |
             +---------+---------------------+---------------------+
        </pre>
    </p>
    <p>
        <b>Multicast a series of messages to multiple EventProcessors</b>
        <pre>
          +-----+                                        track to prevent wrap
   +----->| EP1 |                        +--------------------+----------+----------+
   |      +-----+                        |                    |          |          |
   |                                     |                    v          v          v
+----+    +-----+            +----+    +====+    +====+    +-----+    +-----+    +-----+
| P1 |--->| EP2 |            | P1 |--->| RB |<---| SB |    | EP1 |    | EP2 |    | EP3 |
+----+    +-----+            +----+    +====+    +====+    +-----+    +-----+    +-----+
   |                              claim      get    ^         |          |          |
   |      +-----+                                   |         |          |          |
   +----->| EP3 |                                   +---------+----------+----------+
          +-----+                                                 waitFor
        </pre>
    </p>
    <p>
        <b>Replicate a message then fold back the results</b>
        <pre>
          +-----+                               track to prevent wrap
   +----->| EP1 |-----+                   +-------------------------------+
   |      +-----+     |                   |                               |
   |                  v                   |                               v
+----+             +-----+   +----+    +====+               +=====+    +-----+
| P1 |             | EP3 |   | P1 |--->| RB |<--------------| SB2 |<---| EP3 |
+----+             +-----+   +----+    +====+               +=====+    +-----+
   |                  ^           claim   ^  get               |   waitFor
   |      +-----+     |                   |                    |
   +----->| EP2 |-----+                +=====+    +-----+      |
          +-----+                      | SB1 |<---| EP1 |<-----+
                                       +=====+    +-----+      |
                                          ^                    |
                                          |       +-----+      |
                                          +-------| EP2 |<-----+
                                         waitFor  +-----+
        </pre>
    </p>
    <h2>Code Example</h2>
    <pre>
    // Event holder for data to be exchanged
    public final class ValueEvent
    {
        private long value;

        public long getValue()
        {
            return value;
        }

        public void setValue(final long value)
        {
            this.value = value;
        }

        public final static EventFactory&lt;ValueEvent&gt; EVENT_FACTORY = new EventFactory&lt;ValueEvent&gt;()
        {
            public ValueEvent newInstance()
            {
                return new ValueEvent();
            }
        };
    }

    // Callback handler which can be implemented by EventProcessors
    final EventHandler&lt;ValueEvent&gt; eventHandler = new EventHandler&lt;ValueEvent&gt;()
    {
        public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch)
            throws Exception
        {
            // process a new event as it becomes available.
        }
    };

    RingBuffer&lt;ValueEvent&gt; ringBuffer =
        new RingBuffer&lt;ValueEvent&gt;(ValueEvent.EVENT_FACTORY,
                                   new SingleThreadedClaimStrategy(BUFFER_SIZE),
                                   new SleepingWaitStrategy());

    SequenceBarrier&lt;ValueEvent&gt; sequenceBarrier = ringBuffer.newBarrier();
    BatchEventProcessor&lt;ValueEvent&gt; batchProcessor = new BatchEventProcessor&lt;ValueEvent&gt;(sequenceBarrier, eventHandler);
    ringBuffer.setGatingSequences(batchProcessor.getSequence());

    // Each processor runs on a separate thread
    EXECUTOR.submit(batchProcessor);

    // Publishers claim events in sequence
    long sequence = ringBuffer.next();
    ValueEvent event = ringBuffer.get(sequence);

    event.setValue(1234);

    // publish the event so it is available to EventProcessors
    ringBuffer.publish(sequence);
    </pre></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../overview-summary.html">概览</a></li>
<li class="navBarCell1Rev">程序包</li>
<li>类</li>
<li><a href="package-use.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>上一个程序包</li>
<li><a href="../../../com/lmax/disruptor/dsl/package-summary.html">下一个程序包</a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?com/lmax/disruptor/package-summary.html" target="_top">框架</a></li>
<li><a href="package-summary.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
